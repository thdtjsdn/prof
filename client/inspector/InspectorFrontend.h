// File is generated by Source/WebCore/inspector/CodeGeneratorInspector.py

// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
#ifndef InspectorFrontend_h
#define InspectorFrontend_h

#include "InspectorValues.h"
#include <PlatformString.h>
#include <wtf/PassRefPtr.h>

namespace WebCore {

class InspectorFrontendChannel;

// Both InspectorObject and InspectorArray may or may not be declared at this point as defined by ENABLED_INSPECTOR.
// Double-check we have them at least as forward declaration.
class InspectorArray;
class InspectorObject;

typedef String ErrorString;

#if ENABLE(INSPECTOR)

namespace TypeBuilder {
// Forward declarations.
namespace CSS {
class SourceRange;
class CSSStyle;
} // CSS

#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace Debugger {
class Location;
} // Debugger

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
// End of forward declarations.

namespace Memory {
/* Number of nodes with given name. */
class NodeCount : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        NODE_NAME_SET = 1 << 0,
        COUNT_SET = 1 << 1,
        ALL_FIELDS_SET = (NODE_NAME_SET | COUNT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<NodeCount> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class NodeCount;
    public:

        Builder<STATE | NODE_NAME_SET>& setNodeName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NODE_NAME_SET), property_nodeName_already_set);
            m_result->setString("nodeName", value);
            return castState<NODE_NAME_SET>();
        }

        Builder<STATE | COUNT_SET>& setCount(int value)
        {
            COMPILE_ASSERT(!(STATE & COUNT_SET), property_count_already_set);
            m_result->setNumber("count", value);
            return castState<COUNT_SET>();
        }

        operator RefPtr<NodeCount>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<NodeCount>*>(&m_result);
        }

        operator PassRefPtr<NodeCount> ()
        {
            return RefPtr<NodeCount>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<NodeCount> result = NodeCount::create()
     *     .setNodeName(...)
     *     .setCount(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new NodeCount()));
    }
};

/* Number of JS event listeners by event type. */
class ListenerCount : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        TYPE_SET = 1 << 0,
        COUNT_SET = 1 << 1,
        ALL_FIELDS_SET = (TYPE_SET | COUNT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ListenerCount> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ListenerCount;
    public:

        Builder<STATE | TYPE_SET>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TYPE_SET), property_type_already_set);
            m_result->setString("type", value);
            return castState<TYPE_SET>();
        }

        Builder<STATE | COUNT_SET>& setCount(int value)
        {
            COMPILE_ASSERT(!(STATE & COUNT_SET), property_count_already_set);
            m_result->setNumber("count", value);
            return castState<COUNT_SET>();
        }

        operator RefPtr<ListenerCount>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ListenerCount>*>(&m_result);
        }

        operator PassRefPtr<ListenerCount> ()
        {
            return RefPtr<ListenerCount>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ListenerCount> result = ListenerCount::create()
     *     .setType(...)
     *     .setCount(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new ListenerCount()));
    }
};

class DOMGroup : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        SIZE_SET = 1 << 0,
        TITLE_SET = 1 << 1,
        NODE_COUNT_SET = 1 << 2,
        LISTENER_COUNT_SET = 1 << 3,
        ALL_FIELDS_SET = (SIZE_SET | TITLE_SET | NODE_COUNT_SET | LISTENER_COUNT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<DOMGroup> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class DOMGroup;
    public:

        Builder<STATE | SIZE_SET>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SIZE_SET), property_size_already_set);
            m_result->setNumber("size", value);
            return castState<SIZE_SET>();
        }

        Builder<STATE | TITLE_SET>& setTitle(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TITLE_SET), property_title_already_set);
            m_result->setString("title", value);
            return castState<TITLE_SET>();
        }

        Builder<STATE | NODE_COUNT_SET>& setNodeCount(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & NODE_COUNT_SET), property_nodeCount_already_set);
            m_result->setArray("nodeCount", value);
            return castState<NODE_COUNT_SET>();
        }

        Builder<STATE | LISTENER_COUNT_SET>& setListenerCount(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & LISTENER_COUNT_SET), property_listenerCount_already_set);
            m_result->setArray("listenerCount", value);
            return castState<LISTENER_COUNT_SET>();
        }

        operator RefPtr<DOMGroup>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<DOMGroup>*>(&m_result);
        }

        operator PassRefPtr<DOMGroup> ()
        {
            return RefPtr<DOMGroup>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<DOMGroup> result = DOMGroup::create()
     *     .setSize(...)
     *     .setTitle(...)
     *     .setNodeCount(...)
     *     .setListenerCount(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new DOMGroup()));
    }

    void setDocumentURI(const String& value)
    {
        this->setString("documentURI", value);
    }
};

} // Memory

namespace Page {
/* Resource type as it was perceived by the rendering engine. */
namespace ResourceType {
const char* const document = "Document";
const char* const stylesheet = "Stylesheet";
const char* const image = "Image";
const char* const font = "Font";
const char* const script = "Script";
const char* const xhr = "XHR";
const char* const webSocket = "WebSocket";
const char* const other = "Other";
} // namespace ResourceType

/* Information about the Frame on the page. */
class Frame : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        ID_SET = 1 << 0,
        LOADER_ID_SET = 1 << 1,
        URL_SET = 1 << 2,
        MIME_TYPE_SET = 1 << 3,
        ALL_FIELDS_SET = (ID_SET | LOADER_ID_SET | URL_SET | MIME_TYPE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Frame> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Frame;
    public:

        Builder<STATE | ID_SET>& setId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ID_SET), property_id_already_set);
            m_result->setString("id", value);
            return castState<ID_SET>();
        }

        Builder<STATE | LOADER_ID_SET>& setLoaderId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LOADER_ID_SET), property_loaderId_already_set);
            m_result->setString("loaderId", value);
            return castState<LOADER_ID_SET>();
        }

        Builder<STATE | URL_SET>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & URL_SET), property_url_already_set);
            m_result->setString("url", value);
            return castState<URL_SET>();
        }

        Builder<STATE | MIME_TYPE_SET>& setMimeType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MIME_TYPE_SET), property_mimeType_already_set);
            m_result->setString("mimeType", value);
            return castState<MIME_TYPE_SET>();
        }

        operator RefPtr<Frame>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Frame>*>(&m_result);
        }

        operator PassRefPtr<Frame> ()
        {
            return RefPtr<Frame>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Frame> result = Frame::create()
     *     .setId(...)
     *     .setLoaderId(...)
     *     .setUrl(...)
     *     .setMimeType(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Frame()));
    }

    void setParentId(const String& value)
    {
        this->setString("parentId", value);
    }

    void setName(const String& value)
    {
        this->setString("name", value);
    }
};

/* Information about the Frame hierarchy along with their cached resources. */
class FrameResourceTree : public InspectorObject {
public:
    // Named after property name 'resources' while generating FrameResourceTree.
    // Named as an item of array.
    class ResourcesItem : public InspectorObject {
    public:
        enum {
            NO_FIELDS_SET = 0,
            URL_SET = 1 << 0,
            TYPE_SET = 1 << 1,
            MIME_TYPE_SET = 1 << 2,
            ALL_FIELDS_SET = (URL_SET | TYPE_SET | MIME_TYPE_SET)
        };

        template<int STATE>
        class Builder {
        private:
            RefPtr<InspectorObject> m_result;

            template<int STEP> Builder<STATE | STEP>& castState()
            {
                return *reinterpret_cast<Builder<STATE | STEP>*>(this);
            }

            Builder(PassRefPtr<ResourcesItem> ptr)
            {
                COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
                m_result = ptr;
            }
            friend class ResourcesItem;
        public:
    
            Builder<STATE | URL_SET>& setUrl(const String& value)
            {
                COMPILE_ASSERT(!(STATE & URL_SET), property_url_already_set);
                m_result->setString("url", value);
                return castState<URL_SET>();
            }
    
            Builder<STATE | TYPE_SET>& setType(const String& value)
            {
                COMPILE_ASSERT(!(STATE & TYPE_SET), property_type_already_set);
                m_result->setString("type", value);
                return castState<TYPE_SET>();
            }
    
            Builder<STATE | MIME_TYPE_SET>& setMimeType(const String& value)
            {
                COMPILE_ASSERT(!(STATE & MIME_TYPE_SET), property_mimeType_already_set);
                m_result->setString("mimeType", value);
                return castState<MIME_TYPE_SET>();
            }
    
            operator RefPtr<ResourcesItem>& ()
            {
                COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
                return *reinterpret_cast<RefPtr<ResourcesItem>*>(&m_result);
            }

            operator PassRefPtr<ResourcesItem> ()
            {
                return RefPtr<ResourcesItem>(*this);
            }
        };

        /*
         * Synthetic constructor:
         * RefPtr<ResourcesItem> result = ResourcesItem::create()
         *     .setUrl(...)
         *     .setType(...)
         *     .setMimeType(...);
         */
        static Builder<NO_FIELDS_SET> create()
        {
            return Builder<NO_FIELDS_SET>(adoptRef(new ResourcesItem()));
        }
    };

    enum {
        NO_FIELDS_SET = 0,
        FRAME_SET = 1 << 0,
        RESOURCES_SET = 1 << 1,
        ALL_FIELDS_SET = (FRAME_SET | RESOURCES_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<FrameResourceTree> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class FrameResourceTree;
    public:

        Builder<STATE | FRAME_SET>& setFrame(/*PassRefPtr<TypeBuilder::Page::Frame>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & FRAME_SET), property_frame_already_set);
            m_result->setObject("frame", value);
            return castState<FRAME_SET>();
        }

        Builder<STATE | RESOURCES_SET>& setResources(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & RESOURCES_SET), property_resources_already_set);
            m_result->setArray("resources", value);
            return castState<RESOURCES_SET>();
        }

        operator RefPtr<FrameResourceTree>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<FrameResourceTree>*>(&m_result);
        }

        operator PassRefPtr<FrameResourceTree> ()
        {
            return RefPtr<FrameResourceTree>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FrameResourceTree> result = FrameResourceTree::create()
     *     .setFrame(...)
     *     .setResources(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new FrameResourceTree()));
    }

    void setChildFrames(PassRefPtr<InspectorArray> value)
    {
        this->setArray("childFrames", value);
    }
};

/* Search match for resource. */
class SearchMatch : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        LINE_NUMBER_SET = 1 << 0,
        LINE_CONTENT_SET = 1 << 1,
        ALL_FIELDS_SET = (LINE_NUMBER_SET | LINE_CONTENT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SearchMatch> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SearchMatch;
    public:

        Builder<STATE | LINE_NUMBER_SET>& setLineNumber(double value)
        {
            COMPILE_ASSERT(!(STATE & LINE_NUMBER_SET), property_lineNumber_already_set);
            m_result->setNumber("lineNumber", value);
            return castState<LINE_NUMBER_SET>();
        }

        Builder<STATE | LINE_CONTENT_SET>& setLineContent(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LINE_CONTENT_SET), property_lineContent_already_set);
            m_result->setString("lineContent", value);
            return castState<LINE_CONTENT_SET>();
        }

        operator RefPtr<SearchMatch>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SearchMatch>*>(&m_result);
        }

        operator PassRefPtr<SearchMatch> ()
        {
            return RefPtr<SearchMatch>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SearchMatch> result = SearchMatch::create()
     *     .setLineNumber(...)
     *     .setLineContent(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new SearchMatch()));
    }
};

/* Search result for resource. */
class SearchResult : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        URL_SET = 1 << 0,
        FRAME_ID_SET = 1 << 1,
        MATCHES_COUNT_SET = 1 << 2,
        ALL_FIELDS_SET = (URL_SET | FRAME_ID_SET | MATCHES_COUNT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SearchResult> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SearchResult;
    public:

        Builder<STATE | URL_SET>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & URL_SET), property_url_already_set);
            m_result->setString("url", value);
            return castState<URL_SET>();
        }

        Builder<STATE | FRAME_ID_SET>& setFrameId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FRAME_ID_SET), property_frameId_already_set);
            m_result->setString("frameId", value);
            return castState<FRAME_ID_SET>();
        }

        Builder<STATE | MATCHES_COUNT_SET>& setMatchesCount(double value)
        {
            COMPILE_ASSERT(!(STATE & MATCHES_COUNT_SET), property_matchesCount_already_set);
            m_result->setNumber("matchesCount", value);
            return castState<MATCHES_COUNT_SET>();
        }

        operator RefPtr<SearchResult>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SearchResult>*>(&m_result);
        }

        operator PassRefPtr<SearchResult> ()
        {
            return RefPtr<SearchResult>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SearchResult> result = SearchResult::create()
     *     .setUrl(...)
     *     .setFrameId(...)
     *     .setMatchesCount(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new SearchResult()));
    }
};

/* Cookie object */
class Cookie : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        NAME_SET = 1 << 0,
        VALUE_SET = 1 << 1,
        DOMAIN_SET = 1 << 2,
        PATH_SET = 1 << 3,
        EXPIRES_SET = 1 << 4,
        SIZE_SET = 1 << 5,
        HTTP_ONLY_SET = 1 << 6,
        SECURE_SET = 1 << 7,
        SESSION_SET = 1 << 8,
        ALL_FIELDS_SET = (NAME_SET | VALUE_SET | DOMAIN_SET | PATH_SET | EXPIRES_SET | SIZE_SET | HTTP_ONLY_SET | SECURE_SET | SESSION_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Cookie> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Cookie;
    public:

        Builder<STATE | NAME_SET>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NAME_SET), property_name_already_set);
            m_result->setString("name", value);
            return castState<NAME_SET>();
        }

        Builder<STATE | VALUE_SET>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & VALUE_SET), property_value_already_set);
            m_result->setString("value", value);
            return castState<VALUE_SET>();
        }

        Builder<STATE | DOMAIN_SET>& setDomain(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DOMAIN_SET), property_domain_already_set);
            m_result->setString("domain", value);
            return castState<DOMAIN_SET>();
        }

        Builder<STATE | PATH_SET>& setPath(const String& value)
        {
            COMPILE_ASSERT(!(STATE & PATH_SET), property_path_already_set);
            m_result->setString("path", value);
            return castState<PATH_SET>();
        }

        Builder<STATE | EXPIRES_SET>& setExpires(int value)
        {
            COMPILE_ASSERT(!(STATE & EXPIRES_SET), property_expires_already_set);
            m_result->setNumber("expires", value);
            return castState<EXPIRES_SET>();
        }

        Builder<STATE | SIZE_SET>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SIZE_SET), property_size_already_set);
            m_result->setNumber("size", value);
            return castState<SIZE_SET>();
        }

        Builder<STATE | HTTP_ONLY_SET>& setHttpOnly(bool value)
        {
            COMPILE_ASSERT(!(STATE & HTTP_ONLY_SET), property_httpOnly_already_set);
            m_result->setBoolean("httpOnly", value);
            return castState<HTTP_ONLY_SET>();
        }

        Builder<STATE | SECURE_SET>& setSecure(bool value)
        {
            COMPILE_ASSERT(!(STATE & SECURE_SET), property_secure_already_set);
            m_result->setBoolean("secure", value);
            return castState<SECURE_SET>();
        }

        Builder<STATE | SESSION_SET>& setSession(bool value)
        {
            COMPILE_ASSERT(!(STATE & SESSION_SET), property_session_already_set);
            m_result->setBoolean("session", value);
            return castState<SESSION_SET>();
        }

        operator RefPtr<Cookie>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Cookie>*>(&m_result);
        }

        operator PassRefPtr<Cookie> ()
        {
            return RefPtr<Cookie>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Cookie> result = Cookie::create()
     *     .setName(...)
     *     .setValue(...)
     *     .setDomain(...)
     *     .setPath(...)
     *     .setExpires(...)
     *     .setSize(...)
     *     .setHttpOnly(...)
     *     .setSecure(...)
     *     .setSession(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Cookie()));
    }
};

/* Unique script identifier. */
typedef String ScriptIdentifier;

} // Page

namespace Runtime {
/* Unique object identifier. */
typedef String RemoteObjectId;

/* Mirror object referencing original JavaScript object. */
class RemoteObject : public InspectorObject {
public:
    // // Named after property name 'type' while generating RemoteObject.
    // namespace Type {
    // const char* const object = "object";
    // const char* const function = "function";
    // const char* const undefined = "undefined";
    // const char* const string = "string";
    // const char* const number = "number";
    // const char* const boolean = "boolean";
    // } // namespace Type

    // // Named after property name 'subtype' while generating RemoteObject.
    // namespace Subtype {
    // const char* const array = "array";
    // const char* const null = "null";
    // const char* const node = "node";
    // const char* const regexp = "regexp";
    // const char* const date = "date";
    // } // namespace Subtype

    enum {
        NO_FIELDS_SET = 0,
        TYPE_SET = 1 << 0,
        ALL_FIELDS_SET = (TYPE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<RemoteObject> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class RemoteObject;
    public:

        Builder<STATE | TYPE_SET>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TYPE_SET), property_type_already_set);
            m_result->setString("type", value);
            return castState<TYPE_SET>();
        }

        operator RefPtr<RemoteObject>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<RemoteObject>*>(&m_result);
        }

        operator PassRefPtr<RemoteObject> ()
        {
            return RefPtr<RemoteObject>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<RemoteObject> result = RemoteObject::create()
     *     .setType(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new RemoteObject()));
    }

    void setSubtype(const String& value)
    {
        this->setString("subtype", value);
    }

    void setClassName(const String& value)
    {
        this->setString("className", value);
    }

    void setValue(PassRefPtr<InspectorValue> value)
    {
        this->setValue("value", value);
    }
    using InspectorObject::setValue;


    void setDescription(const String& value)
    {
        this->setString("description", value);
    }

    void setObjectId(const String& value)
    {
        this->setString("objectId", value);
    }
};

/* Object property descriptor. */
class PropertyDescriptor : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        NAME_SET = 1 << 0,
        WRITABLE_SET = 1 << 1,
        CONFIGURABLE_SET = 1 << 2,
        ENUMERABLE_SET = 1 << 3,
        ALL_FIELDS_SET = (NAME_SET | WRITABLE_SET | CONFIGURABLE_SET | ENUMERABLE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<PropertyDescriptor> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class PropertyDescriptor;
    public:

        Builder<STATE | NAME_SET>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NAME_SET), property_name_already_set);
            m_result->setString("name", value);
            return castState<NAME_SET>();
        }

        Builder<STATE | WRITABLE_SET>& setWritable(bool value)
        {
            COMPILE_ASSERT(!(STATE & WRITABLE_SET), property_writable_already_set);
            m_result->setBoolean("writable", value);
            return castState<WRITABLE_SET>();
        }

        Builder<STATE | CONFIGURABLE_SET>& setConfigurable(bool value)
        {
            COMPILE_ASSERT(!(STATE & CONFIGURABLE_SET), property_configurable_already_set);
            m_result->setBoolean("configurable", value);
            return castState<CONFIGURABLE_SET>();
        }

        Builder<STATE | ENUMERABLE_SET>& setEnumerable(bool value)
        {
            COMPILE_ASSERT(!(STATE & ENUMERABLE_SET), property_enumerable_already_set);
            m_result->setBoolean("enumerable", value);
            return castState<ENUMERABLE_SET>();
        }

        operator RefPtr<PropertyDescriptor>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<PropertyDescriptor>*>(&m_result);
        }

        operator PassRefPtr<PropertyDescriptor> ()
        {
            return RefPtr<PropertyDescriptor>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PropertyDescriptor> result = PropertyDescriptor::create()
     *     .setName(...)
     *     .setWritable(...)
     *     .setConfigurable(...)
     *     .setEnumerable(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new PropertyDescriptor()));
    }

    void setValue(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("value", value);
    }
    using InspectorObject::setValue;


    void setGet(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("get", value);
    }

    void setSet(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("set", value);
    }

    void setWasThrown(bool value)
    {
        this->setBoolean("wasThrown", value);
    }
};

/* Represents function call argument. Either remote object id <code>objectId</code> or primitive <code>value</code> or neither of (for undefined) them should be specified. */
class CallArgument : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        ALL_FIELDS_SET = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CallArgument> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CallArgument;
    public:

        operator RefPtr<CallArgument>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CallArgument>*>(&m_result);
        }

        operator PassRefPtr<CallArgument> ()
        {
            return RefPtr<CallArgument>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallArgument> result = CallArgument::create();
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CallArgument()));
    }

    void setValue(PassRefPtr<InspectorValue> value)
    {
        this->setValue("value", value);
    }
    using InspectorObject::setValue;


    void setObjectId(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("objectId", value);
    }
};

} // Runtime

namespace Console {
/* Console message. */
class ConsoleMessage : public InspectorObject {
public:
    // // Named after property name 'source' while generating ConsoleMessage.
    // namespace Source {
    // const char* const html = "html";
    // const char* const wml = "wml";
    // const char* const xml = "xml";
    // const char* const javascript = "javascript";
    // const char* const network = "network";
    // const char* const console_api = "console-api";
    // const char* const other = "other";
    // } // namespace Source

    // // Named after property name 'level' while generating ConsoleMessage.
    // namespace Level {
    // const char* const tip = "tip";
    // const char* const log = "log";
    // const char* const warning = "warning";
    // const char* const error = "error";
    // const char* const debug = "debug";
    // } // namespace Level

    // // Named after property name 'type' while generating ConsoleMessage.
    // namespace Type {
    // const char* const log = "log";
    // const char* const dir = "dir";
    // const char* const dirxml = "dirxml";
    // const char* const trace = "trace";
    // const char* const startGroup = "startGroup";
    // const char* const startGroupCollapsed = "startGroupCollapsed";
    // const char* const endGroup = "endGroup";
    // const char* const assert = "assert";
    // } // namespace Type

    enum {
        NO_FIELDS_SET = 0,
        SOURCE_SET = 1 << 0,
        LEVEL_SET = 1 << 1,
        TEXT_SET = 1 << 2,
        ALL_FIELDS_SET = (SOURCE_SET | LEVEL_SET | TEXT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ConsoleMessage> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ConsoleMessage;
    public:

        Builder<STATE | SOURCE_SET>& setSource(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SOURCE_SET), property_source_already_set);
            m_result->setString("source", value);
            return castState<SOURCE_SET>();
        }

        Builder<STATE | LEVEL_SET>& setLevel(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LEVEL_SET), property_level_already_set);
            m_result->setString("level", value);
            return castState<LEVEL_SET>();
        }

        Builder<STATE | TEXT_SET>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TEXT_SET), property_text_already_set);
            m_result->setString("text", value);
            return castState<TEXT_SET>();
        }

        operator RefPtr<ConsoleMessage>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ConsoleMessage>*>(&m_result);
        }

        operator PassRefPtr<ConsoleMessage> ()
        {
            return RefPtr<ConsoleMessage>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ConsoleMessage> result = ConsoleMessage::create()
     *     .setSource(...)
     *     .setLevel(...)
     *     .setText(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new ConsoleMessage()));
    }

    void setType(const String& value)
    {
        this->setString("type", value);
    }

    void setUrl(const String& value)
    {
        this->setString("url", value);
    }

    void setLine(int value)
    {
        this->setNumber("line", value);
    }

    void setRepeatCount(int value)
    {
        this->setNumber("repeatCount", value);
    }

    void setParameters(PassRefPtr<InspectorArray> value)
    {
        this->setArray("parameters", value);
    }

    void setStackTrace(PassRefPtr<InspectorArray> value)
    {
        this->setArray("stackTrace", value);
    }

    void setNetworkRequestId(const String& value)
    {
        this->setString("networkRequestId", value);
    }
};

/* Stack entry for console errors and assertions. */
class CallFrame : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        FUNCTION_NAME_SET = 1 << 0,
        URL_SET = 1 << 1,
        LINE_NUMBER_SET = 1 << 2,
        COLUMN_NUMBER_SET = 1 << 3,
        ALL_FIELDS_SET = (FUNCTION_NAME_SET | URL_SET | LINE_NUMBER_SET | COLUMN_NUMBER_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CallFrame> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CallFrame;
    public:

        Builder<STATE | FUNCTION_NAME_SET>& setFunctionName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FUNCTION_NAME_SET), property_functionName_already_set);
            m_result->setString("functionName", value);
            return castState<FUNCTION_NAME_SET>();
        }

        Builder<STATE | URL_SET>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & URL_SET), property_url_already_set);
            m_result->setString("url", value);
            return castState<URL_SET>();
        }

        Builder<STATE | LINE_NUMBER_SET>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LINE_NUMBER_SET), property_lineNumber_already_set);
            m_result->setNumber("lineNumber", value);
            return castState<LINE_NUMBER_SET>();
        }

        Builder<STATE | COLUMN_NUMBER_SET>& setColumnNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & COLUMN_NUMBER_SET), property_columnNumber_already_set);
            m_result->setNumber("columnNumber", value);
            return castState<COLUMN_NUMBER_SET>();
        }

        operator RefPtr<CallFrame>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CallFrame>*>(&m_result);
        }

        operator PassRefPtr<CallFrame> ()
        {
            return RefPtr<CallFrame>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallFrame> result = CallFrame::create()
     *     .setFunctionName(...)
     *     .setUrl(...)
     *     .setLineNumber(...)
     *     .setColumnNumber(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CallFrame()));
    }
};

} // Console

namespace Network {
/* Unique loader identifier. */
typedef String LoaderId;

/* Unique frame identifier. */
typedef String FrameId;

/* Unique request identifier. */
typedef String RequestId;

/* Timing information for the request. */
class ResourceTiming : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        REQUEST_TIME_SET = 1 << 0,
        PROXY_START_SET = 1 << 1,
        PROXY_END_SET = 1 << 2,
        DNS_START_SET = 1 << 3,
        DNS_END_SET = 1 << 4,
        CONNECT_START_SET = 1 << 5,
        CONNECT_END_SET = 1 << 6,
        SSL_START_SET = 1 << 7,
        SSL_END_SET = 1 << 8,
        SEND_START_SET = 1 << 9,
        SEND_END_SET = 1 << 10,
        RECEIVE_HEADERS_END_SET = 1 << 11,
        ALL_FIELDS_SET = (REQUEST_TIME_SET | PROXY_START_SET | PROXY_END_SET | DNS_START_SET | DNS_END_SET | CONNECT_START_SET | CONNECT_END_SET | SSL_START_SET | SSL_END_SET | SEND_START_SET | SEND_END_SET | RECEIVE_HEADERS_END_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ResourceTiming> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ResourceTiming;
    public:

        Builder<STATE | REQUEST_TIME_SET>& setRequestTime(double value)
        {
            COMPILE_ASSERT(!(STATE & REQUEST_TIME_SET), property_requestTime_already_set);
            m_result->setNumber("requestTime", value);
            return castState<REQUEST_TIME_SET>();
        }

        Builder<STATE | PROXY_START_SET>& setProxyStart(double value)
        {
            COMPILE_ASSERT(!(STATE & PROXY_START_SET), property_proxyStart_already_set);
            m_result->setNumber("proxyStart", value);
            return castState<PROXY_START_SET>();
        }

        Builder<STATE | PROXY_END_SET>& setProxyEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & PROXY_END_SET), property_proxyEnd_already_set);
            m_result->setNumber("proxyEnd", value);
            return castState<PROXY_END_SET>();
        }

        Builder<STATE | DNS_START_SET>& setDnsStart(double value)
        {
            COMPILE_ASSERT(!(STATE & DNS_START_SET), property_dnsStart_already_set);
            m_result->setNumber("dnsStart", value);
            return castState<DNS_START_SET>();
        }

        Builder<STATE | DNS_END_SET>& setDnsEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & DNS_END_SET), property_dnsEnd_already_set);
            m_result->setNumber("dnsEnd", value);
            return castState<DNS_END_SET>();
        }

        Builder<STATE | CONNECT_START_SET>& setConnectStart(double value)
        {
            COMPILE_ASSERT(!(STATE & CONNECT_START_SET), property_connectStart_already_set);
            m_result->setNumber("connectStart", value);
            return castState<CONNECT_START_SET>();
        }

        Builder<STATE | CONNECT_END_SET>& setConnectEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & CONNECT_END_SET), property_connectEnd_already_set);
            m_result->setNumber("connectEnd", value);
            return castState<CONNECT_END_SET>();
        }

        Builder<STATE | SSL_START_SET>& setSslStart(double value)
        {
            COMPILE_ASSERT(!(STATE & SSL_START_SET), property_sslStart_already_set);
            m_result->setNumber("sslStart", value);
            return castState<SSL_START_SET>();
        }

        Builder<STATE | SSL_END_SET>& setSslEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & SSL_END_SET), property_sslEnd_already_set);
            m_result->setNumber("sslEnd", value);
            return castState<SSL_END_SET>();
        }

        Builder<STATE | SEND_START_SET>& setSendStart(double value)
        {
            COMPILE_ASSERT(!(STATE & SEND_START_SET), property_sendStart_already_set);
            m_result->setNumber("sendStart", value);
            return castState<SEND_START_SET>();
        }

        Builder<STATE | SEND_END_SET>& setSendEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & SEND_END_SET), property_sendEnd_already_set);
            m_result->setNumber("sendEnd", value);
            return castState<SEND_END_SET>();
        }

        Builder<STATE | RECEIVE_HEADERS_END_SET>& setReceiveHeadersEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & RECEIVE_HEADERS_END_SET), property_receiveHeadersEnd_already_set);
            m_result->setNumber("receiveHeadersEnd", value);
            return castState<RECEIVE_HEADERS_END_SET>();
        }

        operator RefPtr<ResourceTiming>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ResourceTiming>*>(&m_result);
        }

        operator PassRefPtr<ResourceTiming> ()
        {
            return RefPtr<ResourceTiming>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ResourceTiming> result = ResourceTiming::create()
     *     .setRequestTime(...)
     *     .setProxyStart(...)
     *     .setProxyEnd(...)
     *     .setDnsStart(...)
     *     .setDnsEnd(...)
     *     .setConnectStart(...)
     *     .setConnectEnd(...)
     *     .setSslStart(...)
     *     .setSslEnd(...)
     *     .setSendStart(...)
     *     .setSendEnd(...)
     *     .setReceiveHeadersEnd(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new ResourceTiming()));
    }
};

/* HTTP request data. */
class Request : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        URL_SET = 1 << 0,
        METHOD_SET = 1 << 1,
        HEADERS_SET = 1 << 2,
        ALL_FIELDS_SET = (URL_SET | METHOD_SET | HEADERS_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Request> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Request;
    public:

        Builder<STATE | URL_SET>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & URL_SET), property_url_already_set);
            m_result->setString("url", value);
            return castState<URL_SET>();
        }

        Builder<STATE | METHOD_SET>& setMethod(const String& value)
        {
            COMPILE_ASSERT(!(STATE & METHOD_SET), property_method_already_set);
            m_result->setString("method", value);
            return castState<METHOD_SET>();
        }

        Builder<STATE | HEADERS_SET>& setHeaders(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HEADERS_SET), property_headers_already_set);
            m_result->setObject("headers", value);
            return castState<HEADERS_SET>();
        }

        operator RefPtr<Request>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Request>*>(&m_result);
        }

        operator PassRefPtr<Request> ()
        {
            return RefPtr<Request>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Request> result = Request::create()
     *     .setUrl(...)
     *     .setMethod(...)
     *     .setHeaders(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Request()));
    }

    void setPostData(const String& value)
    {
        this->setString("postData", value);
    }
};

/* HTTP response data. */
class Response : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        URL_SET = 1 << 0,
        STATUS_SET = 1 << 1,
        STATUS_TEXT_SET = 1 << 2,
        HEADERS_SET = 1 << 3,
        MIME_TYPE_SET = 1 << 4,
        CONNECTION_REUSED_SET = 1 << 5,
        CONNECTION_ID_SET = 1 << 6,
        ALL_FIELDS_SET = (URL_SET | STATUS_SET | STATUS_TEXT_SET | HEADERS_SET | MIME_TYPE_SET | CONNECTION_REUSED_SET | CONNECTION_ID_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Response> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Response;
    public:

        Builder<STATE | URL_SET>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & URL_SET), property_url_already_set);
            m_result->setString("url", value);
            return castState<URL_SET>();
        }

        Builder<STATE | STATUS_SET>& setStatus(double value)
        {
            COMPILE_ASSERT(!(STATE & STATUS_SET), property_status_already_set);
            m_result->setNumber("status", value);
            return castState<STATUS_SET>();
        }

        Builder<STATE | STATUS_TEXT_SET>& setStatusText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & STATUS_TEXT_SET), property_statusText_already_set);
            m_result->setString("statusText", value);
            return castState<STATUS_TEXT_SET>();
        }

        Builder<STATE | HEADERS_SET>& setHeaders(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HEADERS_SET), property_headers_already_set);
            m_result->setObject("headers", value);
            return castState<HEADERS_SET>();
        }

        Builder<STATE | MIME_TYPE_SET>& setMimeType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MIME_TYPE_SET), property_mimeType_already_set);
            m_result->setString("mimeType", value);
            return castState<MIME_TYPE_SET>();
        }

        Builder<STATE | CONNECTION_REUSED_SET>& setConnectionReused(bool value)
        {
            COMPILE_ASSERT(!(STATE & CONNECTION_REUSED_SET), property_connectionReused_already_set);
            m_result->setBoolean("connectionReused", value);
            return castState<CONNECTION_REUSED_SET>();
        }

        Builder<STATE | CONNECTION_ID_SET>& setConnectionId(double value)
        {
            COMPILE_ASSERT(!(STATE & CONNECTION_ID_SET), property_connectionId_already_set);
            m_result->setNumber("connectionId", value);
            return castState<CONNECTION_ID_SET>();
        }

        operator RefPtr<Response>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Response>*>(&m_result);
        }

        operator PassRefPtr<Response> ()
        {
            return RefPtr<Response>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Response> result = Response::create()
     *     .setUrl(...)
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .setMimeType(...)
     *     .setConnectionReused(...)
     *     .setConnectionId(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Response()));
    }

    void setHeadersText(const String& value)
    {
        this->setString("headersText", value);
    }

    void setRequestHeaders(PassRefPtr<InspectorObject> value)
    {
        this->setObject("requestHeaders", value);
    }

    void setRequestHeadersText(const String& value)
    {
        this->setString("requestHeadersText", value);
    }

    void setFromDiskCache(bool value)
    {
        this->setBoolean("fromDiskCache", value);
    }

    void setTiming(/*PassRefPtr<TypeBuilder::Network::ResourceTiming>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("timing", value);
    }
};

/* WebSocket request data. */
class WebSocketRequest : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        REQUEST_KEY3_SET = 1 << 0,
        HEADERS_SET = 1 << 1,
        ALL_FIELDS_SET = (REQUEST_KEY3_SET | HEADERS_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<WebSocketRequest> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class WebSocketRequest;
    public:

        Builder<STATE | REQUEST_KEY3_SET>& setRequestKey3(const String& value)
        {
            COMPILE_ASSERT(!(STATE & REQUEST_KEY3_SET), property_requestKey3_already_set);
            m_result->setString("requestKey3", value);
            return castState<REQUEST_KEY3_SET>();
        }

        Builder<STATE | HEADERS_SET>& setHeaders(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HEADERS_SET), property_headers_already_set);
            m_result->setObject("headers", value);
            return castState<HEADERS_SET>();
        }

        operator RefPtr<WebSocketRequest>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<WebSocketRequest>*>(&m_result);
        }

        operator PassRefPtr<WebSocketRequest> ()
        {
            return RefPtr<WebSocketRequest>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketRequest> result = WebSocketRequest::create()
     *     .setRequestKey3(...)
     *     .setHeaders(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new WebSocketRequest()));
    }
};

/* WebSocket response data. */
class WebSocketResponse : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        STATUS_SET = 1 << 0,
        STATUS_TEXT_SET = 1 << 1,
        HEADERS_SET = 1 << 2,
        CHALLENGE_RESPONSE_SET = 1 << 3,
        ALL_FIELDS_SET = (STATUS_SET | STATUS_TEXT_SET | HEADERS_SET | CHALLENGE_RESPONSE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<WebSocketResponse> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class WebSocketResponse;
    public:

        Builder<STATE | STATUS_SET>& setStatus(double value)
        {
            COMPILE_ASSERT(!(STATE & STATUS_SET), property_status_already_set);
            m_result->setNumber("status", value);
            return castState<STATUS_SET>();
        }

        Builder<STATE | STATUS_TEXT_SET>& setStatusText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & STATUS_TEXT_SET), property_statusText_already_set);
            m_result->setString("statusText", value);
            return castState<STATUS_TEXT_SET>();
        }

        Builder<STATE | HEADERS_SET>& setHeaders(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & HEADERS_SET), property_headers_already_set);
            m_result->setObject("headers", value);
            return castState<HEADERS_SET>();
        }

        Builder<STATE | CHALLENGE_RESPONSE_SET>& setChallengeResponse(const String& value)
        {
            COMPILE_ASSERT(!(STATE & CHALLENGE_RESPONSE_SET), property_challengeResponse_already_set);
            m_result->setString("challengeResponse", value);
            return castState<CHALLENGE_RESPONSE_SET>();
        }

        operator RefPtr<WebSocketResponse>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<WebSocketResponse>*>(&m_result);
        }

        operator PassRefPtr<WebSocketResponse> ()
        {
            return RefPtr<WebSocketResponse>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<WebSocketResponse> result = WebSocketResponse::create()
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .setChallengeResponse(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new WebSocketResponse()));
    }
};

/* Information about the cached resource. */
class CachedResource : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        URL_SET = 1 << 0,
        TYPE_SET = 1 << 1,
        RESPONSE_SET = 1 << 2,
        BODY_SIZE_SET = 1 << 3,
        ALL_FIELDS_SET = (URL_SET | TYPE_SET | RESPONSE_SET | BODY_SIZE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CachedResource> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CachedResource;
    public:

        Builder<STATE | URL_SET>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & URL_SET), property_url_already_set);
            m_result->setString("url", value);
            return castState<URL_SET>();
        }

        Builder<STATE | TYPE_SET>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TYPE_SET), property_type_already_set);
            m_result->setString("type", value);
            return castState<TYPE_SET>();
        }

        Builder<STATE | RESPONSE_SET>& setResponse(/*PassRefPtr<TypeBuilder::Network::Response>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & RESPONSE_SET), property_response_already_set);
            m_result->setObject("response", value);
            return castState<RESPONSE_SET>();
        }

        Builder<STATE | BODY_SIZE_SET>& setBodySize(double value)
        {
            COMPILE_ASSERT(!(STATE & BODY_SIZE_SET), property_bodySize_already_set);
            m_result->setNumber("bodySize", value);
            return castState<BODY_SIZE_SET>();
        }

        operator RefPtr<CachedResource>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CachedResource>*>(&m_result);
        }

        operator PassRefPtr<CachedResource> ()
        {
            return RefPtr<CachedResource>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CachedResource> result = CachedResource::create()
     *     .setUrl(...)
     *     .setType(...)
     *     .setResponse(...)
     *     .setBodySize(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CachedResource()));
    }
};

/* Information about the request initiator. */
class Initiator : public InspectorObject {
public:
    // // Named after property name 'type' while generating Initiator.
    // namespace Type {
    // const char* const parser = "parser";
    // const char* const script = "script";
    // const char* const other = "other";
    // } // namespace Type

    enum {
        NO_FIELDS_SET = 0,
        TYPE_SET = 1 << 0,
        ALL_FIELDS_SET = (TYPE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Initiator> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Initiator;
    public:

        Builder<STATE | TYPE_SET>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TYPE_SET), property_type_already_set);
            m_result->setString("type", value);
            return castState<TYPE_SET>();
        }

        operator RefPtr<Initiator>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Initiator>*>(&m_result);
        }

        operator PassRefPtr<Initiator> ()
        {
            return RefPtr<Initiator>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Initiator> result = Initiator::create()
     *     .setType(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Initiator()));
    }

    void setStackTrace(PassRefPtr<InspectorArray> value)
    {
        this->setArray("stackTrace", value);
    }

    void setUrl(const String& value)
    {
        this->setString("url", value);
    }

    void setLineNumber(double value)
    {
        this->setNumber("lineNumber", value);
    }
};

} // Network

#if ENABLE(SQL_DATABASE)
namespace Database {
/* Database object. */
class Database : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        ID_SET = 1 << 0,
        DOMAIN_SET = 1 << 1,
        NAME_SET = 1 << 2,
        VERSION_SET = 1 << 3,
        ALL_FIELDS_SET = (ID_SET | DOMAIN_SET | NAME_SET | VERSION_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Database> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Database;
    public:

        Builder<STATE | ID_SET>& setId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ID_SET), property_id_already_set);
            m_result->setString("id", value);
            return castState<ID_SET>();
        }

        Builder<STATE | DOMAIN_SET>& setDomain(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DOMAIN_SET), property_domain_already_set);
            m_result->setString("domain", value);
            return castState<DOMAIN_SET>();
        }

        Builder<STATE | NAME_SET>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NAME_SET), property_name_already_set);
            m_result->setString("name", value);
            return castState<NAME_SET>();
        }

        Builder<STATE | VERSION_SET>& setVersion(const String& value)
        {
            COMPILE_ASSERT(!(STATE & VERSION_SET), property_version_already_set);
            m_result->setString("version", value);
            return castState<VERSION_SET>();
        }

        operator RefPtr<Database>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Database>*>(&m_result);
        }

        operator PassRefPtr<Database> ()
        {
            return RefPtr<Database>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Database> result = Database::create()
     *     .setId(...)
     *     .setDomain(...)
     *     .setName(...)
     *     .setVersion(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Database()));
    }
};

} // Database

#endif // ENABLE(SQL_DATABASE)
namespace DOMStorage {
/* DOM Storage entry. */
class Entry : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        HOST_SET = 1 << 0,
        IS_LOCAL_STORAGE_SET = 1 << 1,
        ID_SET = 1 << 2,
        ALL_FIELDS_SET = (HOST_SET | IS_LOCAL_STORAGE_SET | ID_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Entry> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Entry;
    public:

        Builder<STATE | HOST_SET>& setHost(const String& value)
        {
            COMPILE_ASSERT(!(STATE & HOST_SET), property_host_already_set);
            m_result->setString("host", value);
            return castState<HOST_SET>();
        }

        Builder<STATE | IS_LOCAL_STORAGE_SET>& setIsLocalStorage(bool value)
        {
            COMPILE_ASSERT(!(STATE & IS_LOCAL_STORAGE_SET), property_isLocalStorage_already_set);
            m_result->setBoolean("isLocalStorage", value);
            return castState<IS_LOCAL_STORAGE_SET>();
        }

        Builder<STATE | ID_SET>& setId(double value)
        {
            COMPILE_ASSERT(!(STATE & ID_SET), property_id_already_set);
            m_result->setNumber("id", value);
            return castState<ID_SET>();
        }

        operator RefPtr<Entry>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Entry>*>(&m_result);
        }

        operator PassRefPtr<Entry> ()
        {
            return RefPtr<Entry>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Entry> result = Entry::create()
     *     .setHost(...)
     *     .setIsLocalStorage(...)
     *     .setId(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Entry()));
    }
};

} // DOMStorage

namespace ApplicationCache {
/* Detailed application cache resource information. */
class ApplicationCacheResource : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        URL_SET = 1 << 0,
        SIZE_SET = 1 << 1,
        TYPE_SET = 1 << 2,
        ALL_FIELDS_SET = (URL_SET | SIZE_SET | TYPE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ApplicationCacheResource> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ApplicationCacheResource;
    public:

        Builder<STATE | URL_SET>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & URL_SET), property_url_already_set);
            m_result->setString("url", value);
            return castState<URL_SET>();
        }

        Builder<STATE | SIZE_SET>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SIZE_SET), property_size_already_set);
            m_result->setNumber("size", value);
            return castState<SIZE_SET>();
        }

        Builder<STATE | TYPE_SET>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TYPE_SET), property_type_already_set);
            m_result->setString("type", value);
            return castState<TYPE_SET>();
        }

        operator RefPtr<ApplicationCacheResource>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ApplicationCacheResource>*>(&m_result);
        }

        operator PassRefPtr<ApplicationCacheResource> ()
        {
            return RefPtr<ApplicationCacheResource>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ApplicationCacheResource> result = ApplicationCacheResource::create()
     *     .setUrl(...)
     *     .setSize(...)
     *     .setType(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new ApplicationCacheResource()));
    }
};

/* Detailed application cache information. */
class ApplicationCache : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        MANIFEST_U_R_L_SET = 1 << 0,
        SIZE_SET = 1 << 1,
        CREATION_TIME_SET = 1 << 2,
        UPDATE_TIME_SET = 1 << 3,
        RESOURCES_SET = 1 << 4,
        ALL_FIELDS_SET = (MANIFEST_U_R_L_SET | SIZE_SET | CREATION_TIME_SET | UPDATE_TIME_SET | RESOURCES_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<ApplicationCache> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class ApplicationCache;
    public:

        Builder<STATE | MANIFEST_U_R_L_SET>& setManifestURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MANIFEST_U_R_L_SET), property_manifestURL_already_set);
            m_result->setString("manifestURL", value);
            return castState<MANIFEST_U_R_L_SET>();
        }

        Builder<STATE | SIZE_SET>& setSize(double value)
        {
            COMPILE_ASSERT(!(STATE & SIZE_SET), property_size_already_set);
            m_result->setNumber("size", value);
            return castState<SIZE_SET>();
        }

        Builder<STATE | CREATION_TIME_SET>& setCreationTime(double value)
        {
            COMPILE_ASSERT(!(STATE & CREATION_TIME_SET), property_creationTime_already_set);
            m_result->setNumber("creationTime", value);
            return castState<CREATION_TIME_SET>();
        }

        Builder<STATE | UPDATE_TIME_SET>& setUpdateTime(double value)
        {
            COMPILE_ASSERT(!(STATE & UPDATE_TIME_SET), property_updateTime_already_set);
            m_result->setNumber("updateTime", value);
            return castState<UPDATE_TIME_SET>();
        }

        Builder<STATE | RESOURCES_SET>& setResources(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & RESOURCES_SET), property_resources_already_set);
            m_result->setArray("resources", value);
            return castState<RESOURCES_SET>();
        }

        operator RefPtr<ApplicationCache>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<ApplicationCache>*>(&m_result);
        }

        operator PassRefPtr<ApplicationCache> ()
        {
            return RefPtr<ApplicationCache>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<ApplicationCache> result = ApplicationCache::create()
     *     .setManifestURL(...)
     *     .setSize(...)
     *     .setCreationTime(...)
     *     .setUpdateTime(...)
     *     .setResources(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new ApplicationCache()));
    }
};

/* Frame identifier - manifest URL pair. */
class FrameWithManifest : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        FRAME_ID_SET = 1 << 0,
        MANIFEST_U_R_L_SET = 1 << 1,
        STATUS_SET = 1 << 2,
        ALL_FIELDS_SET = (FRAME_ID_SET | MANIFEST_U_R_L_SET | STATUS_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<FrameWithManifest> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class FrameWithManifest;
    public:

        Builder<STATE | FRAME_ID_SET>& setFrameId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FRAME_ID_SET), property_frameId_already_set);
            m_result->setString("frameId", value);
            return castState<FRAME_ID_SET>();
        }

        Builder<STATE | MANIFEST_U_R_L_SET>& setManifestURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MANIFEST_U_R_L_SET), property_manifestURL_already_set);
            m_result->setString("manifestURL", value);
            return castState<MANIFEST_U_R_L_SET>();
        }

        Builder<STATE | STATUS_SET>& setStatus(int value)
        {
            COMPILE_ASSERT(!(STATE & STATUS_SET), property_status_already_set);
            m_result->setNumber("status", value);
            return castState<STATUS_SET>();
        }

        operator RefPtr<FrameWithManifest>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<FrameWithManifest>*>(&m_result);
        }

        operator PassRefPtr<FrameWithManifest> ()
        {
            return RefPtr<FrameWithManifest>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<FrameWithManifest> result = FrameWithManifest::create()
     *     .setFrameId(...)
     *     .setManifestURL(...)
     *     .setStatus(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new FrameWithManifest()));
    }
};

} // ApplicationCache

namespace DOM {
/* DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type. */
class Node : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        NODE_ID_SET = 1 << 0,
        NODE_TYPE_SET = 1 << 1,
        NODE_NAME_SET = 1 << 2,
        LOCAL_NAME_SET = 1 << 3,
        NODE_VALUE_SET = 1 << 4,
        ALL_FIELDS_SET = (NODE_ID_SET | NODE_TYPE_SET | NODE_NAME_SET | LOCAL_NAME_SET | NODE_VALUE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Node> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Node;
    public:

        Builder<STATE | NODE_ID_SET>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NODE_ID_SET), property_nodeId_already_set);
            m_result->setNumber("nodeId", value);
            return castState<NODE_ID_SET>();
        }

        Builder<STATE | NODE_TYPE_SET>& setNodeType(int value)
        {
            COMPILE_ASSERT(!(STATE & NODE_TYPE_SET), property_nodeType_already_set);
            m_result->setNumber("nodeType", value);
            return castState<NODE_TYPE_SET>();
        }

        Builder<STATE | NODE_NAME_SET>& setNodeName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NODE_NAME_SET), property_nodeName_already_set);
            m_result->setString("nodeName", value);
            return castState<NODE_NAME_SET>();
        }

        Builder<STATE | LOCAL_NAME_SET>& setLocalName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LOCAL_NAME_SET), property_localName_already_set);
            m_result->setString("localName", value);
            return castState<LOCAL_NAME_SET>();
        }

        Builder<STATE | NODE_VALUE_SET>& setNodeValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NODE_VALUE_SET), property_nodeValue_already_set);
            m_result->setString("nodeValue", value);
            return castState<NODE_VALUE_SET>();
        }

        operator RefPtr<Node>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Node>*>(&m_result);
        }

        operator PassRefPtr<Node> ()
        {
            return RefPtr<Node>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Node> result = Node::create()
     *     .setNodeId(...)
     *     .setNodeType(...)
     *     .setNodeName(...)
     *     .setLocalName(...)
     *     .setNodeValue(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Node()));
    }

    void setChildNodeCount(int value)
    {
        this->setNumber("childNodeCount", value);
    }

    void setChildren(PassRefPtr<InspectorArray> value)
    {
        this->setArray("children", value);
    }

    void setAttributes(PassRefPtr<InspectorArray> value)
    {
        this->setArray("attributes", value);
    }

    void setDocumentURL(const String& value)
    {
        this->setString("documentURL", value);
    }

    void setPublicId(const String& value)
    {
        this->setString("publicId", value);
    }

    void setSystemId(const String& value)
    {
        this->setString("systemId", value);
    }

    void setInternalSubset(const String& value)
    {
        this->setString("internalSubset", value);
    }

    void setXmlVersion(const String& value)
    {
        this->setString("xmlVersion", value);
    }

    void setName(const String& value)
    {
        this->setString("name", value);
    }

    void setValue(const String& value)
    {
        this->setString("value", value);
    }
    using InspectorObject::setValue;

};

/* DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type. */
class EventListener : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        TYPE_SET = 1 << 0,
        USE_CAPTURE_SET = 1 << 1,
        IS_ATTRIBUTE_SET = 1 << 2,
        NODE_ID_SET = 1 << 3,
        HANDLER_BODY_SET = 1 << 4,
        ALL_FIELDS_SET = (TYPE_SET | USE_CAPTURE_SET | IS_ATTRIBUTE_SET | NODE_ID_SET | HANDLER_BODY_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<EventListener> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class EventListener;
    public:

        Builder<STATE | TYPE_SET>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TYPE_SET), property_type_already_set);
            m_result->setString("type", value);
            return castState<TYPE_SET>();
        }

        Builder<STATE | USE_CAPTURE_SET>& setUseCapture(bool value)
        {
            COMPILE_ASSERT(!(STATE & USE_CAPTURE_SET), property_useCapture_already_set);
            m_result->setBoolean("useCapture", value);
            return castState<USE_CAPTURE_SET>();
        }

        Builder<STATE | IS_ATTRIBUTE_SET>& setIsAttribute(bool value)
        {
            COMPILE_ASSERT(!(STATE & IS_ATTRIBUTE_SET), property_isAttribute_already_set);
            m_result->setBoolean("isAttribute", value);
            return castState<IS_ATTRIBUTE_SET>();
        }

        Builder<STATE | NODE_ID_SET>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NODE_ID_SET), property_nodeId_already_set);
            m_result->setNumber("nodeId", value);
            return castState<NODE_ID_SET>();
        }

        Builder<STATE | HANDLER_BODY_SET>& setHandlerBody(const String& value)
        {
            COMPILE_ASSERT(!(STATE & HANDLER_BODY_SET), property_handlerBody_already_set);
            m_result->setString("handlerBody", value);
            return castState<HANDLER_BODY_SET>();
        }

        operator RefPtr<EventListener>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<EventListener>*>(&m_result);
        }

        operator PassRefPtr<EventListener> ()
        {
            return RefPtr<EventListener>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<EventListener> result = EventListener::create()
     *     .setType(...)
     *     .setUseCapture(...)
     *     .setIsAttribute(...)
     *     .setNodeId(...)
     *     .setHandlerBody(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new EventListener()));
    }

    void setLocation(/*PassRefPtr<TypeBuilder::Debugger::Location>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("location", value);
    }
};

/* A structure holding an RGBA color. */
// Type originally was named 'RGBA'.
class Rgba : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        R_SET = 1 << 0,
        G_SET = 1 << 1,
        B_SET = 1 << 2,
        ALL_FIELDS_SET = (R_SET | G_SET | B_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Rgba> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Rgba;
    public:

        Builder<STATE | R_SET>& setR(int value)
        {
            COMPILE_ASSERT(!(STATE & R_SET), property_r_already_set);
            m_result->setNumber("r", value);
            return castState<R_SET>();
        }

        Builder<STATE | G_SET>& setG(int value)
        {
            COMPILE_ASSERT(!(STATE & G_SET), property_g_already_set);
            m_result->setNumber("g", value);
            return castState<G_SET>();
        }

        Builder<STATE | B_SET>& setB(int value)
        {
            COMPILE_ASSERT(!(STATE & B_SET), property_b_already_set);
            m_result->setNumber("b", value);
            return castState<B_SET>();
        }

        operator RefPtr<Rgba>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Rgba>*>(&m_result);
        }

        operator PassRefPtr<Rgba> ()
        {
            return RefPtr<Rgba>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Rgba> result = Rgba::create()
     *     .setR(...)
     *     .setG(...)
     *     .setB(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Rgba()));
    }

    void setA(double value)
    {
        this->setNumber("a", value);
    }
};

/* Configuration data for the highlighting of page elements. */
class HighlightConfig : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        ALL_FIELDS_SET = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<HighlightConfig> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class HighlightConfig;
    public:

        operator RefPtr<HighlightConfig>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<HighlightConfig>*>(&m_result);
        }

        operator PassRefPtr<HighlightConfig> ()
        {
            return RefPtr<HighlightConfig>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<HighlightConfig> result = HighlightConfig::create();
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new HighlightConfig()));
    }

    void setShowInfo(bool value)
    {
        this->setBoolean("showInfo", value);
    }

    void setContentColor(/*PassRefPtr<TypeBuilder::DOM::Rgba>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("contentColor", value);
    }

    void setPaddingColor(/*PassRefPtr<TypeBuilder::DOM::Rgba>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("paddingColor", value);
    }

    void setBorderColor(/*PassRefPtr<TypeBuilder::DOM::Rgba>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("borderColor", value);
    }

    void setMarginColor(/*PassRefPtr<TypeBuilder::DOM::Rgba>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("marginColor", value);
    }
};

} // DOM

namespace CSS {
/* This object identifies a CSS style in a unique way. */
class CSSStyleId : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        STYLE_SHEET_ID_SET = 1 << 0,
        ORDINAL_SET = 1 << 1,
        ALL_FIELDS_SET = (STYLE_SHEET_ID_SET | ORDINAL_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyleId> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleId;
    public:

        Builder<STATE | STYLE_SHEET_ID_SET>& setStyleSheetId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & STYLE_SHEET_ID_SET), property_styleSheetId_already_set);
            m_result->setString("styleSheetId", value);
            return castState<STYLE_SHEET_ID_SET>();
        }

        Builder<STATE | ORDINAL_SET>& setOrdinal(int value)
        {
            COMPILE_ASSERT(!(STATE & ORDINAL_SET), property_ordinal_already_set);
            m_result->setNumber("ordinal", value);
            return castState<ORDINAL_SET>();
        }

        operator RefPtr<CSSStyleId>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyleId>*>(&m_result);
        }

        operator PassRefPtr<CSSStyleId> ()
        {
            return RefPtr<CSSStyleId>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleId> result = CSSStyleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSStyleId()));
    }
};

/* This object identifies a CSS rule in a unique way. */
class CSSRuleId : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        STYLE_SHEET_ID_SET = 1 << 0,
        ORDINAL_SET = 1 << 1,
        ALL_FIELDS_SET = (STYLE_SHEET_ID_SET | ORDINAL_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSRuleId> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSRuleId;
    public:

        Builder<STATE | STYLE_SHEET_ID_SET>& setStyleSheetId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & STYLE_SHEET_ID_SET), property_styleSheetId_already_set);
            m_result->setString("styleSheetId", value);
            return castState<STYLE_SHEET_ID_SET>();
        }

        Builder<STATE | ORDINAL_SET>& setOrdinal(int value)
        {
            COMPILE_ASSERT(!(STATE & ORDINAL_SET), property_ordinal_already_set);
            m_result->setNumber("ordinal", value);
            return castState<ORDINAL_SET>();
        }

        operator RefPtr<CSSRuleId>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSRuleId>*>(&m_result);
        }

        operator PassRefPtr<CSSRuleId> ()
        {
            return RefPtr<CSSRuleId>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSRuleId> result = CSSRuleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSRuleId()));
    }
};

/* CSS rule collection for a single pseudo style. */
class PseudoIdRules : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        PSEUDO_ID_SET = 1 << 0,
        RULES_SET = 1 << 1,
        ALL_FIELDS_SET = (PSEUDO_ID_SET | RULES_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<PseudoIdRules> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class PseudoIdRules;
    public:

        Builder<STATE | PSEUDO_ID_SET>& setPseudoId(int value)
        {
            COMPILE_ASSERT(!(STATE & PSEUDO_ID_SET), property_pseudoId_already_set);
            m_result->setNumber("pseudoId", value);
            return castState<PSEUDO_ID_SET>();
        }

        Builder<STATE | RULES_SET>& setRules(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & RULES_SET), property_rules_already_set);
            m_result->setArray("rules", value);
            return castState<RULES_SET>();
        }

        operator RefPtr<PseudoIdRules>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<PseudoIdRules>*>(&m_result);
        }

        operator PassRefPtr<PseudoIdRules> ()
        {
            return RefPtr<PseudoIdRules>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<PseudoIdRules> result = PseudoIdRules::create()
     *     .setPseudoId(...)
     *     .setRules(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new PseudoIdRules()));
    }
};

/* CSS rule collection for a single pseudo style. */
class InheritedStyleEntry : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        MATCHED_CSS_RULES_SET = 1 << 0,
        ALL_FIELDS_SET = (MATCHED_CSS_RULES_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<InheritedStyleEntry> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class InheritedStyleEntry;
    public:

        Builder<STATE | MATCHED_CSS_RULES_SET>& setMatchedCSSRules(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & MATCHED_CSS_RULES_SET), property_matchedCSSRules_already_set);
            m_result->setArray("matchedCSSRules", value);
            return castState<MATCHED_CSS_RULES_SET>();
        }

        operator RefPtr<InheritedStyleEntry>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<InheritedStyleEntry>*>(&m_result);
        }

        operator PassRefPtr<InheritedStyleEntry> ()
        {
            return RefPtr<InheritedStyleEntry>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<InheritedStyleEntry> result = InheritedStyleEntry::create()
     *     .setMatchedCSSRules(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new InheritedStyleEntry()));
    }

    void setInlineStyle(/*PassRefPtr<TypeBuilder::CSS::CSSStyle>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("inlineStyle", value);
    }
};

/* CSS style information for a DOM style attribute. */
class CSSStyleAttribute : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        NAME_SET = 1 << 0,
        STYLE_SET = 1 << 1,
        ALL_FIELDS_SET = (NAME_SET | STYLE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyleAttribute> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleAttribute;
    public:

        Builder<STATE | NAME_SET>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NAME_SET), property_name_already_set);
            m_result->setString("name", value);
            return castState<NAME_SET>();
        }

        Builder<STATE | STYLE_SET>& setStyle(/*PassRefPtr<TypeBuilder::CSS::CSSStyle>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & STYLE_SET), property_style_already_set);
            m_result->setObject("style", value);
            return castState<STYLE_SET>();
        }

        operator RefPtr<CSSStyleAttribute>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyleAttribute>*>(&m_result);
        }

        operator PassRefPtr<CSSStyleAttribute> ()
        {
            return RefPtr<CSSStyleAttribute>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleAttribute> result = CSSStyleAttribute::create()
     *     .setName(...)
     *     .setStyle(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSStyleAttribute()));
    }
};

/* CSS stylesheet metainformation. */
class CSSStyleSheetHeader : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        STYLE_SHEET_ID_SET = 1 << 0,
        SOURCE_U_R_L_SET = 1 << 1,
        TITLE_SET = 1 << 2,
        DISABLED_SET = 1 << 3,
        ALL_FIELDS_SET = (STYLE_SHEET_ID_SET | SOURCE_U_R_L_SET | TITLE_SET | DISABLED_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyleSheetHeader> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleSheetHeader;
    public:

        Builder<STATE | STYLE_SHEET_ID_SET>& setStyleSheetId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & STYLE_SHEET_ID_SET), property_styleSheetId_already_set);
            m_result->setString("styleSheetId", value);
            return castState<STYLE_SHEET_ID_SET>();
        }

        Builder<STATE | SOURCE_U_R_L_SET>& setSourceURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SOURCE_U_R_L_SET), property_sourceURL_already_set);
            m_result->setString("sourceURL", value);
            return castState<SOURCE_U_R_L_SET>();
        }

        Builder<STATE | TITLE_SET>& setTitle(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TITLE_SET), property_title_already_set);
            m_result->setString("title", value);
            return castState<TITLE_SET>();
        }

        Builder<STATE | DISABLED_SET>& setDisabled(bool value)
        {
            COMPILE_ASSERT(!(STATE & DISABLED_SET), property_disabled_already_set);
            m_result->setBoolean("disabled", value);
            return castState<DISABLED_SET>();
        }

        operator RefPtr<CSSStyleSheetHeader>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyleSheetHeader>*>(&m_result);
        }

        operator PassRefPtr<CSSStyleSheetHeader> ()
        {
            return RefPtr<CSSStyleSheetHeader>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleSheetHeader> result = CSSStyleSheetHeader::create()
     *     .setStyleSheetId(...)
     *     .setSourceURL(...)
     *     .setTitle(...)
     *     .setDisabled(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSStyleSheetHeader()));
    }
};

/* CSS stylesheet contents. */
class CSSStyleSheetBody : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        STYLE_SHEET_ID_SET = 1 << 0,
        RULES_SET = 1 << 1,
        ALL_FIELDS_SET = (STYLE_SHEET_ID_SET | RULES_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyleSheetBody> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyleSheetBody;
    public:

        Builder<STATE | STYLE_SHEET_ID_SET>& setStyleSheetId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & STYLE_SHEET_ID_SET), property_styleSheetId_already_set);
            m_result->setString("styleSheetId", value);
            return castState<STYLE_SHEET_ID_SET>();
        }

        Builder<STATE | RULES_SET>& setRules(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & RULES_SET), property_rules_already_set);
            m_result->setArray("rules", value);
            return castState<RULES_SET>();
        }

        operator RefPtr<CSSStyleSheetBody>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyleSheetBody>*>(&m_result);
        }

        operator PassRefPtr<CSSStyleSheetBody> ()
        {
            return RefPtr<CSSStyleSheetBody>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyleSheetBody> result = CSSStyleSheetBody::create()
     *     .setStyleSheetId(...)
     *     .setRules(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSStyleSheetBody()));
    }

    void setText(const String& value)
    {
        this->setString("text", value);
    }
};

/* CSS rule representation. */
class CSSRule : public InspectorObject {
public:
    // // Named after property name 'origin' while generating CSSRule.
    // namespace Origin {
    // const char* const user = "user";
    // const char* const user_agent = "user-agent";
    // const char* const inspector = "inspector";
    // const char* const regular = "regular";
    // } // namespace Origin

    enum {
        NO_FIELDS_SET = 0,
        SELECTOR_TEXT_SET = 1 << 0,
        SOURCE_LINE_SET = 1 << 1,
        ORIGIN_SET = 1 << 2,
        STYLE_SET = 1 << 3,
        ALL_FIELDS_SET = (SELECTOR_TEXT_SET | SOURCE_LINE_SET | ORIGIN_SET | STYLE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSRule> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSRule;
    public:

        Builder<STATE | SELECTOR_TEXT_SET>& setSelectorText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SELECTOR_TEXT_SET), property_selectorText_already_set);
            m_result->setString("selectorText", value);
            return castState<SELECTOR_TEXT_SET>();
        }

        Builder<STATE | SOURCE_LINE_SET>& setSourceLine(int value)
        {
            COMPILE_ASSERT(!(STATE & SOURCE_LINE_SET), property_sourceLine_already_set);
            m_result->setNumber("sourceLine", value);
            return castState<SOURCE_LINE_SET>();
        }

        Builder<STATE | ORIGIN_SET>& setOrigin(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ORIGIN_SET), property_origin_already_set);
            m_result->setString("origin", value);
            return castState<ORIGIN_SET>();
        }

        Builder<STATE | STYLE_SET>& setStyle(/*PassRefPtr<TypeBuilder::CSS::CSSStyle>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & STYLE_SET), property_style_already_set);
            m_result->setObject("style", value);
            return castState<STYLE_SET>();
        }

        operator RefPtr<CSSRule>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSRule>*>(&m_result);
        }

        operator PassRefPtr<CSSRule> ()
        {
            return RefPtr<CSSRule>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSRule> result = CSSRule::create()
     *     .setSelectorText(...)
     *     .setSourceLine(...)
     *     .setOrigin(...)
     *     .setStyle(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSRule()));
    }

    void setRuleId(/*PassRefPtr<TypeBuilder::CSS::CSSRuleId>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("ruleId", value);
    }

    void setSourceURL(const String& value)
    {
        this->setString("sourceURL", value);
    }

    void setSelectorRange(/*PassRefPtr<TypeBuilder::CSS::SourceRange>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("selectorRange", value);
    }

    void setMedia(PassRefPtr<InspectorArray> value)
    {
        this->setArray("media", value);
    }
};

/* Text range within a resource. */
class SourceRange : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        START_SET = 1 << 0,
        END_SET = 1 << 1,
        ALL_FIELDS_SET = (START_SET | END_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SourceRange> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SourceRange;
    public:

        Builder<STATE | START_SET>& setStart(int value)
        {
            COMPILE_ASSERT(!(STATE & START_SET), property_start_already_set);
            m_result->setNumber("start", value);
            return castState<START_SET>();
        }

        Builder<STATE | END_SET>& setEnd(int value)
        {
            COMPILE_ASSERT(!(STATE & END_SET), property_end_already_set);
            m_result->setNumber("end", value);
            return castState<END_SET>();
        }

        operator RefPtr<SourceRange>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SourceRange>*>(&m_result);
        }

        operator PassRefPtr<SourceRange> ()
        {
            return RefPtr<SourceRange>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SourceRange> result = SourceRange::create()
     *     .setStart(...)
     *     .setEnd(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new SourceRange()));
    }
};

class CSSComputedStyleProperty : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        NAME_SET = 1 << 0,
        VALUE_SET = 1 << 1,
        ALL_FIELDS_SET = (NAME_SET | VALUE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSComputedStyleProperty> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSComputedStyleProperty;
    public:

        Builder<STATE | NAME_SET>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NAME_SET), property_name_already_set);
            m_result->setString("name", value);
            return castState<NAME_SET>();
        }

        Builder<STATE | VALUE_SET>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & VALUE_SET), property_value_already_set);
            m_result->setString("value", value);
            return castState<VALUE_SET>();
        }

        operator RefPtr<CSSComputedStyleProperty>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSComputedStyleProperty>*>(&m_result);
        }

        operator PassRefPtr<CSSComputedStyleProperty> ()
        {
            return RefPtr<CSSComputedStyleProperty>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSComputedStyleProperty> result = CSSComputedStyleProperty::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSComputedStyleProperty()));
    }
};

/* CSS style representation. */
class CSSStyle : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        CSS_PROPERTIES_SET = 1 << 0,
        SHORTHAND_ENTRIES_SET = 1 << 1,
        WIDTH_SET = 1 << 2,
        HEIGHT_SET = 1 << 3,
        ALL_FIELDS_SET = (CSS_PROPERTIES_SET | SHORTHAND_ENTRIES_SET | WIDTH_SET | HEIGHT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSStyle> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSStyle;
    public:

        Builder<STATE | CSS_PROPERTIES_SET>& setCssProperties(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & CSS_PROPERTIES_SET), property_cssProperties_already_set);
            m_result->setArray("cssProperties", value);
            return castState<CSS_PROPERTIES_SET>();
        }

        Builder<STATE | SHORTHAND_ENTRIES_SET>& setShorthandEntries(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & SHORTHAND_ENTRIES_SET), property_shorthandEntries_already_set);
            m_result->setArray("shorthandEntries", value);
            return castState<SHORTHAND_ENTRIES_SET>();
        }

        Builder<STATE | WIDTH_SET>& setWidth(const String& value)
        {
            COMPILE_ASSERT(!(STATE & WIDTH_SET), property_width_already_set);
            m_result->setString("width", value);
            return castState<WIDTH_SET>();
        }

        Builder<STATE | HEIGHT_SET>& setHeight(const String& value)
        {
            COMPILE_ASSERT(!(STATE & HEIGHT_SET), property_height_already_set);
            m_result->setString("height", value);
            return castState<HEIGHT_SET>();
        }

        operator RefPtr<CSSStyle>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSStyle>*>(&m_result);
        }

        operator PassRefPtr<CSSStyle> ()
        {
            return RefPtr<CSSStyle>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSStyle> result = CSSStyle::create()
     *     .setCssProperties(...)
     *     .setShorthandEntries(...)
     *     .setWidth(...)
     *     .setHeight(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSStyle()));
    }

    void setStyleId(/*PassRefPtr<TypeBuilder::CSS::CSSStyleId>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("styleId", value);
    }

    void setCssText(const String& value)
    {
        this->setString("cssText", value);
    }

    void setRange(/*PassRefPtr<TypeBuilder::CSS::SourceRange>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("range", value);
    }
};

/* CSS style effective visual dimensions and source offsets. */
class CSSProperty : public InspectorObject {
public:
    // // Named after property name 'status' while generating CSSProperty.
    // namespace Status {
    // const char* const active = "active";
    // const char* const inactive = "inactive";
    // const char* const disabled = "disabled";
    // const char* const style = "style";
    // } // namespace Status

    enum {
        NO_FIELDS_SET = 0,
        NAME_SET = 1 << 0,
        VALUE_SET = 1 << 1,
        ALL_FIELDS_SET = (NAME_SET | VALUE_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSProperty> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSProperty;
    public:

        Builder<STATE | NAME_SET>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NAME_SET), property_name_already_set);
            m_result->setString("name", value);
            return castState<NAME_SET>();
        }

        Builder<STATE | VALUE_SET>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & VALUE_SET), property_value_already_set);
            m_result->setString("value", value);
            return castState<VALUE_SET>();
        }

        operator RefPtr<CSSProperty>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSProperty>*>(&m_result);
        }

        operator PassRefPtr<CSSProperty> ()
        {
            return RefPtr<CSSProperty>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSProperty> result = CSSProperty::create()
     *     .setName(...)
     *     .setValue(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSProperty()));
    }

    void setPriority(const String& value)
    {
        this->setString("priority", value);
    }

    void setImplicit(bool value)
    {
        this->setBoolean("implicit", value);
    }

    void setText(const String& value)
    {
        this->setString("text", value);
    }

    void setParsedOk(bool value)
    {
        this->setBoolean("parsedOk", value);
    }

    void setStatus(const String& value)
    {
        this->setString("status", value);
    }

    void setShorthandName(const String& value)
    {
        this->setString("shorthandName", value);
    }

    void setRange(/*PassRefPtr<TypeBuilder::CSS::SourceRange>*/ PassRefPtr<InspectorObject> value)
    {
        this->setObject("range", value);
    }
};

/* CSS media query descriptor. */
class CSSMedia : public InspectorObject {
public:
    // // Named after property name 'source' while generating CSSMedia.
    // namespace Source {
    // const char* const mediaRule = "mediaRule";
    // const char* const importRule = "importRule";
    // const char* const stylesheet = "stylesheet";
    // } // namespace Source

    enum {
        NO_FIELDS_SET = 0,
        TEXT_SET = 1 << 0,
        ALL_FIELDS_SET = (TEXT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CSSMedia> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CSSMedia;
    public:

        Builder<STATE | TEXT_SET>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TEXT_SET), property_text_already_set);
            m_result->setString("text", value);
            return castState<TEXT_SET>();
        }

        operator RefPtr<CSSMedia>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CSSMedia>*>(&m_result);
        }

        operator PassRefPtr<CSSMedia> ()
        {
            return RefPtr<CSSMedia>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CSSMedia> result = CSSMedia::create()
     *     .setText(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CSSMedia()));
    }

    void setSource(const String& value)
    {
        this->setString("source", value);
    }

    void setSourceURL(const String& value)
    {
        this->setString("sourceURL", value);
    }

    void setSourceLine(int value)
    {
        this->setNumber("sourceLine", value);
    }
};

/* CSS selector profile entry. */
class SelectorProfileEntry : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        SELECTOR_SET = 1 << 0,
        TIME_SET = 1 << 1,
        HIT_COUNT_SET = 1 << 2,
        MATCH_COUNT_SET = 1 << 3,
        ALL_FIELDS_SET = (SELECTOR_SET | TIME_SET | HIT_COUNT_SET | MATCH_COUNT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SelectorProfileEntry> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SelectorProfileEntry;
    public:

        Builder<STATE | SELECTOR_SET>& setSelector(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SELECTOR_SET), property_selector_already_set);
            m_result->setString("selector", value);
            return castState<SELECTOR_SET>();
        }

        Builder<STATE | TIME_SET>& setTime(double value)
        {
            COMPILE_ASSERT(!(STATE & TIME_SET), property_time_already_set);
            m_result->setNumber("time", value);
            return castState<TIME_SET>();
        }

        Builder<STATE | HIT_COUNT_SET>& setHitCount(int value)
        {
            COMPILE_ASSERT(!(STATE & HIT_COUNT_SET), property_hitCount_already_set);
            m_result->setNumber("hitCount", value);
            return castState<HIT_COUNT_SET>();
        }

        Builder<STATE | MATCH_COUNT_SET>& setMatchCount(int value)
        {
            COMPILE_ASSERT(!(STATE & MATCH_COUNT_SET), property_matchCount_already_set);
            m_result->setNumber("matchCount", value);
            return castState<MATCH_COUNT_SET>();
        }

        operator RefPtr<SelectorProfileEntry>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SelectorProfileEntry>*>(&m_result);
        }

        operator PassRefPtr<SelectorProfileEntry> ()
        {
            return RefPtr<SelectorProfileEntry>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SelectorProfileEntry> result = SelectorProfileEntry::create()
     *     .setSelector(...)
     *     .setTime(...)
     *     .setHitCount(...)
     *     .setMatchCount(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new SelectorProfileEntry()));
    }
};

class SelectorProfile : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        TOTAL_TIME_SET = 1 << 0,
        DATA_SET = 1 << 1,
        ALL_FIELDS_SET = (TOTAL_TIME_SET | DATA_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<SelectorProfile> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class SelectorProfile;
    public:

        Builder<STATE | TOTAL_TIME_SET>& setTotalTime(double value)
        {
            COMPILE_ASSERT(!(STATE & TOTAL_TIME_SET), property_totalTime_already_set);
            m_result->setNumber("totalTime", value);
            return castState<TOTAL_TIME_SET>();
        }

        Builder<STATE | DATA_SET>& setData(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & DATA_SET), property_data_already_set);
            m_result->setArray("data", value);
            return castState<DATA_SET>();
        }

        operator RefPtr<SelectorProfile>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<SelectorProfile>*>(&m_result);
        }

        operator PassRefPtr<SelectorProfile> ()
        {
            return RefPtr<SelectorProfile>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<SelectorProfile> result = SelectorProfile::create()
     *     .setTotalTime(...)
     *     .setData(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new SelectorProfile()));
    }
};

} // CSS

namespace Timeline {
/* Timeline record contains information about the recorded activity. */
class TimelineEvent : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        TYPE_SET = 1 << 0,
        DATA_SET = 1 << 1,
        ALL_FIELDS_SET = (TYPE_SET | DATA_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<TimelineEvent> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class TimelineEvent;
    public:

        Builder<STATE | TYPE_SET>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TYPE_SET), property_type_already_set);
            m_result->setString("type", value);
            return castState<TYPE_SET>();
        }

        Builder<STATE | DATA_SET>& setData(PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & DATA_SET), property_data_already_set);
            m_result->setObject("data", value);
            return castState<DATA_SET>();
        }

        operator RefPtr<TimelineEvent>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<TimelineEvent>*>(&m_result);
        }

        operator PassRefPtr<TimelineEvent> ()
        {
            return RefPtr<TimelineEvent>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<TimelineEvent> result = TimelineEvent::create()
     *     .setType(...)
     *     .setData(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new TimelineEvent()));
    }

    void setChildren(PassRefPtr<InspectorArray> value)
    {
        this->setArray("children", value);
    }
};

} // Timeline

#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace Debugger {
/* Breakpoint identifier. */
typedef String BreakpointId;

/* Unique script identifier. */
typedef String ScriptId;

/* Call frame identifier. */
typedef String CallFrameId;

/* Location in the source code. */
class Location : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        SCRIPT_ID_SET = 1 << 0,
        LINE_NUMBER_SET = 1 << 1,
        ALL_FIELDS_SET = (SCRIPT_ID_SET | LINE_NUMBER_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Location> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Location;
    public:

        Builder<STATE | SCRIPT_ID_SET>& setScriptId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SCRIPT_ID_SET), property_scriptId_already_set);
            m_result->setString("scriptId", value);
            return castState<SCRIPT_ID_SET>();
        }

        Builder<STATE | LINE_NUMBER_SET>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LINE_NUMBER_SET), property_lineNumber_already_set);
            m_result->setNumber("lineNumber", value);
            return castState<LINE_NUMBER_SET>();
        }

        operator RefPtr<Location>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Location>*>(&m_result);
        }

        operator PassRefPtr<Location> ()
        {
            return RefPtr<Location>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Location> result = Location::create()
     *     .setScriptId(...)
     *     .setLineNumber(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Location()));
    }

    void setColumnNumber(int value)
    {
        this->setNumber("columnNumber", value);
    }
};

/* JavaScript call frame. Array of call frames form the call stack. */
class CallFrame : public InspectorObject {
public:
    enum {
        NO_FIELDS_SET = 0,
        CALL_FRAME_ID_SET = 1 << 0,
        FUNCTION_NAME_SET = 1 << 1,
        LOCATION_SET = 1 << 2,
        SCOPE_CHAIN_SET = 1 << 3,
        THIS_SET = 1 << 4,
        ALL_FIELDS_SET = (CALL_FRAME_ID_SET | FUNCTION_NAME_SET | LOCATION_SET | SCOPE_CHAIN_SET | THIS_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<CallFrame> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class CallFrame;
    public:

        Builder<STATE | CALL_FRAME_ID_SET>& setCallFrameId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & CALL_FRAME_ID_SET), property_callFrameId_already_set);
            m_result->setString("callFrameId", value);
            return castState<CALL_FRAME_ID_SET>();
        }

        Builder<STATE | FUNCTION_NAME_SET>& setFunctionName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FUNCTION_NAME_SET), property_functionName_already_set);
            m_result->setString("functionName", value);
            return castState<FUNCTION_NAME_SET>();
        }

        Builder<STATE | LOCATION_SET>& setLocation(/*PassRefPtr<TypeBuilder::Debugger::Location>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & LOCATION_SET), property_location_already_set);
            m_result->setObject("location", value);
            return castState<LOCATION_SET>();
        }

        Builder<STATE | SCOPE_CHAIN_SET>& setScopeChain(PassRefPtr<InspectorArray> value)
        {
            COMPILE_ASSERT(!(STATE & SCOPE_CHAIN_SET), property_scopeChain_already_set);
            m_result->setArray("scopeChain", value);
            return castState<SCOPE_CHAIN_SET>();
        }

        Builder<STATE | THIS_SET>& setThis(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & THIS_SET), property_this_already_set);
            m_result->setObject("this", value);
            return castState<THIS_SET>();
        }

        operator RefPtr<CallFrame>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<CallFrame>*>(&m_result);
        }

        operator PassRefPtr<CallFrame> ()
        {
            return RefPtr<CallFrame>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<CallFrame> result = CallFrame::create()
     *     .setCallFrameId(...)
     *     .setFunctionName(...)
     *     .setLocation(...)
     *     .setScopeChain(...)
     *     .setThis(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new CallFrame()));
    }
};

/* Scope description. */
class Scope : public InspectorObject {
public:
    // // Named after property name 'type' while generating Scope.
    // namespace Type {
    // const char* const global = "global";
    // const char* const local = "local";
    // const char* const with = "with";
    // const char* const closure = "closure";
    // const char* const catch = "catch";
    // } // namespace Type

    enum {
        NO_FIELDS_SET = 0,
        TYPE_SET = 1 << 0,
        OBJECT_SET = 1 << 1,
        ALL_FIELDS_SET = (TYPE_SET | OBJECT_SET)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr<Scope> ptr)
        {
            COMPILE_ASSERT(STATE == NO_FIELDS_SET, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Scope;
    public:

        Builder<STATE | TYPE_SET>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TYPE_SET), property_type_already_set);
            m_result->setString("type", value);
            return castState<TYPE_SET>();
        }

        Builder<STATE | OBJECT_SET>& setObject(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> value)
        {
            COMPILE_ASSERT(!(STATE & OBJECT_SET), property_object_already_set);
            m_result->setObject("object", value);
            return castState<OBJECT_SET>();
        }

        operator RefPtr<Scope>& ()
        {
            COMPILE_ASSERT(STATE == ALL_FIELDS_SET, result_is_not_ready);
            return *reinterpret_cast<RefPtr<Scope>*>(&m_result);
        }

        operator PassRefPtr<Scope> ()
        {
            return RefPtr<Scope>(*this);
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Scope> result = Scope::create()
     *     .setType(...)
     *     .setObject(...);
     */
    static Builder<NO_FIELDS_SET> create()
    {
        return Builder<NO_FIELDS_SET>(adoptRef(new Scope()));
    }
};

} // Debugger

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace DOMDebugger {
/* DOM breakpoint type. */
namespace DOMBreakpointType {
const char* const subtree_modified = "subtree-modified";
const char* const attribute_modified = "attribute-modified";
const char* const node_removed = "node-removed";
} // namespace DOMBreakpointType

} // DOMDebugger

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
#if ENABLE(JAVASCRIPT_DEBUGGER)
namespace Profiler {
} // Profiler

#endif // ENABLE(JAVASCRIPT_DEBUGGER)

} // namespace TypeBuilder

#endif // ENABLE(INSPECTOR)

class InspectorFrontend {
public:
    InspectorFrontend(InspectorFrontendChannel*);


    class Inspector {
    public:
        Inspector(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void evaluateForTestInFrontend(int testCallId, const String& script);
        void inspect(/*PassRefPtr<TypeBuilder::Runtime::RemoteObject>*/ PassRefPtr<InspectorObject> object, PassRefPtr<InspectorObject> hints);
        void didCreateWorker(int id, const String& url, bool isShared);
        void didDestroyWorker(int id);
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Inspector* inspector() { return &m_inspector; }

    class Memory {
    public:
        Memory(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Memory* memory() { return &m_memory; }

    class Page {
    public:
        Page(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void domContentEventFired(double timestamp);
        void loadEventFired(double timestamp);
        void frameNavigated(/*PassRefPtr<TypeBuilder::Page::Frame>*/ PassRefPtr<InspectorObject> frame);
        void frameDetached(const String& frameId);
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Page* page() { return &m_page; }

    class Runtime {
    public:
        Runtime(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Runtime* runtime() { return &m_runtime; }

    class Console {
    public:
        Console(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void messageAdded(/*PassRefPtr<TypeBuilder::Console::ConsoleMessage>*/ PassRefPtr<InspectorObject> message);
        void messageRepeatCountUpdated(int count);
        void messagesCleared();
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Console* console() { return &m_console; }

    class Network {
    public:
        Network(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void requestWillBeSent(const String& requestId, const String& frameId, const String& loaderId, const String& documentURL, /*PassRefPtr<TypeBuilder::Network::Request>*/ PassRefPtr<InspectorObject> request, double timestamp, /*PassRefPtr<TypeBuilder::Network::Initiator>*/ PassRefPtr<InspectorObject> initiator, PassRefPtr<InspectorArray> stackTrace, /*PassRefPtr<TypeBuilder::Network::Response>*/ PassRefPtr<InspectorObject> redirectResponse);
        void requestServedFromCache(const String& requestId);
        void responseReceived(const String& requestId, const String& frameId, const String& loaderId, double timestamp, const String& type, /*PassRefPtr<TypeBuilder::Network::Response>*/ PassRefPtr<InspectorObject> response);
        void dataReceived(const String& requestId, double timestamp, int dataLength, int encodedDataLength);
        void loadingFinished(const String& requestId, double timestamp);
        void loadingFailed(const String& requestId, double timestamp, const String& errorText, const bool* const canceled);
        void requestServedFromMemoryCache(const String& requestId, const String& frameId, const String& loaderId, const String& documentURL, double timestamp, /*PassRefPtr<TypeBuilder::Network::Initiator>*/ PassRefPtr<InspectorObject> initiator, /*PassRefPtr<TypeBuilder::Network::CachedResource>*/ PassRefPtr<InspectorObject> resource);
        void webSocketWillSendHandshakeRequest(const String& requestId, double timestamp, /*PassRefPtr<TypeBuilder::Network::WebSocketRequest>*/ PassRefPtr<InspectorObject> request);
        void webSocketHandshakeResponseReceived(const String& requestId, double timestamp, /*PassRefPtr<TypeBuilder::Network::WebSocketResponse>*/ PassRefPtr<InspectorObject> response);
        void webSocketCreated(const String& requestId, const String& url);
        void webSocketClosed(const String& requestId, double timestamp);
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Network* network() { return &m_network; }

#if ENABLE(SQL_DATABASE)
    class Database {
    public:
        Database(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void addDatabase(/*PassRefPtr<TypeBuilder::Database::Database>*/ PassRefPtr<InspectorObject> database);
        void sqlTransactionSucceeded(int transactionId, PassRefPtr<InspectorArray> columnNames, PassRefPtr<InspectorArray> values);
        void sqlTransactionFailed(int transactionId, PassRefPtr<InspectorObject> sqlError);
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Database* database() { return &m_database; }

#endif // ENABLE(SQL_DATABASE)
    class DOMStorage {
    public:
        DOMStorage(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void addDOMStorage(/*PassRefPtr<TypeBuilder::DOMStorage::Entry>*/ PassRefPtr<InspectorObject> storage);
        void updateDOMStorage(int storageId);
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    DOMStorage* domstorage() { return &m_domstorage; }

    class ApplicationCache {
    public:
        ApplicationCache(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void applicationCacheStatusUpdated(const String& frameId, const String& manifestURL, int status);
        void networkStateUpdated(bool isNowOnline);
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    ApplicationCache* applicationcache() { return &m_applicationcache; }

#if ENABLE(FILE_SYSTEM)
    class FileSystem {
    public:
        FileSystem(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    FileSystem* filesystem() { return &m_filesystem; }

#endif // ENABLE(FILE_SYSTEM)
    class DOM {
    public:
        DOM(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void documentUpdated();
        void setChildNodes(int parentId, PassRefPtr<InspectorArray> nodes);
        void attributeModified(int nodeId, const String& name, const String& value);
        void attributeRemoved(int nodeId, const String& name);
        void inlineStyleInvalidated(PassRefPtr<InspectorArray> nodeIds);
        void characterDataModified(int nodeId, const String& characterData);
        void childNodeCountUpdated(int nodeId, int childNodeCount);
        void childNodeInserted(int parentNodeId, int previousNodeId, /*PassRefPtr<TypeBuilder::DOM::Node>*/ PassRefPtr<InspectorObject> node);
        void childNodeRemoved(int parentNodeId, int nodeId);
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    DOM* dom() { return &m_dom; }

    class CSS {
    public:
        CSS(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void mediaQueryResultChanged();
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    CSS* css() { return &m_css; }

    class Timeline {
    public:
        Timeline(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void eventRecorded(/*PassRefPtr<TypeBuilder::Timeline::TimelineEvent>*/ PassRefPtr<InspectorObject> record);
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Timeline* timeline() { return &m_timeline; }

#if ENABLE(JAVASCRIPT_DEBUGGER)
    class Debugger {
    public:
        Debugger(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void globalObjectCleared();
        void scriptParsed(const String& scriptId, const String& url, int startLine, int startColumn, int endLine, int endColumn, const bool* const isContentScript, const String& sourceMapURL);
        void scriptFailedToParse(const String& url, const String& scriptSource, int startLine, int errorLine, const String& errorMessage);
        void breakpointResolved(const String& breakpointId, /*PassRefPtr<TypeBuilder::Debugger::Location>*/ PassRefPtr<InspectorObject> location);
    // // Named after parameter name 'reason' while generating event paused.
    // namespace Reason {
    // const char* const xhr = "XHR";
    // const char* const dom = "DOM";
    // const char* const eventListener = "EventListener";
    // const char* const exception = "exception";
    // const char* const other = "other";
    // } // namespace Reason

        void paused(PassRefPtr<InspectorArray> callFrames, const String& reason, PassRefPtr<InspectorObject> data);
        void resumed();
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Debugger* debugger() { return &m_debugger; }

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
#if ENABLE(JAVASCRIPT_DEBUGGER)
    class DOMDebugger {
    public:
        DOMDebugger(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    DOMDebugger* domdebugger() { return &m_domdebugger; }

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
#if ENABLE(JAVASCRIPT_DEBUGGER)
    class Profiler {
    public:
        Profiler(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void addProfileHeader(PassRefPtr<InspectorObject> header);
        void addHeapSnapshotChunk(int uid, const String& chunk);
        void finishHeapSnapshot(int uid);
        void setRecordingProfile(bool isProfiling);
        void resetProfiles();
        void reportHeapSnapshotProgress(int done, int total);
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Profiler* profiler() { return &m_profiler; }

#endif // ENABLE(JAVASCRIPT_DEBUGGER)
#if ENABLE(WORKERS)
    class Worker {
    public:
        Worker(InspectorFrontendChannel* inspectorFrontendChannel) : m_inspectorFrontendChannel(inspectorFrontendChannel) { }
        void workerCreated(int workerId, const String& url, bool inspectorConnected);
        void workerTerminated(int workerId);
        void dispatchMessageFromWorker(int workerId, PassRefPtr<InspectorObject> message);
        void disconnectedFromWorker();
        void setInspectorFrontendChannel(InspectorFrontendChannel* inspectorFrontendChannel) { m_inspectorFrontendChannel = inspectorFrontendChannel; }
        InspectorFrontendChannel* getInspectorFrontendChannel() { return m_inspectorFrontendChannel; }
    private:
        InspectorFrontendChannel* m_inspectorFrontendChannel;
    };

    Worker* worker() { return &m_worker; }

#endif // ENABLE(WORKERS)

private:
    InspectorFrontendChannel* m_inspectorFrontendChannel;
    Inspector m_inspector;
    Memory m_memory;
    Page m_page;
    Runtime m_runtime;
    Console m_console;
    Network m_network;
#if ENABLE(SQL_DATABASE)
    Database m_database;
#endif // ENABLE(SQL_DATABASE)
    DOMStorage m_domstorage;
    ApplicationCache m_applicationcache;
#if ENABLE(FILE_SYSTEM)
    FileSystem m_filesystem;
#endif // ENABLE(FILE_SYSTEM)
    DOM m_dom;
    CSS m_css;
    Timeline m_timeline;
#if ENABLE(JAVASCRIPT_DEBUGGER)
    Debugger m_debugger;
#endif // ENABLE(JAVASCRIPT_DEBUGGER)
#if ENABLE(JAVASCRIPT_DEBUGGER)
    DOMDebugger m_domdebugger;
#endif // ENABLE(JAVASCRIPT_DEBUGGER)
#if ENABLE(JAVASCRIPT_DEBUGGER)
    Profiler m_profiler;
#endif // ENABLE(JAVASCRIPT_DEBUGGER)
#if ENABLE(WORKERS)
    Worker m_worker;
#endif // ENABLE(WORKERS)
};

} // namespace WebCore
#endif // !defined(InspectorFrontend_h)
